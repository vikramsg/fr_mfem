// Copyright (c) 2010, Lawrence Livermore National Security, LLC. Produced at
// the Lawrence Livermore National Laboratory. LLNL-CODE-443211. All Rights
// reserved. See file COPYRIGHT for details.
//
// This file is part of the MFEM library. For more information and source code
// availability see http://mfem.org.
//
// MFEM is free software; you can redistribute it and/or modify it under the
// terms of the GNU Lesser General Public License (as published by the Free
// Software Foundation) version 2.1 dated February 1999.

/*
  ---[ Defines Known At Compile-Time ]------------
  ELEMENT_BATCH : How many elements are in each
  .               computation batch
  NUM_DOFS      : Dofs per element
  NUM_QPTS      : Quadrature points per element
  CONST_COEFF   : If the coefficient is constant, pass it
  .               as a define
  ================================================
*/

#if OCCA_USING_GPU
#  define TUPLE3_ORDER idxOrder(2,0,1)
#  define TUPLE4_ORDER idxOrder(3,0,1,2)
#else
#  define TUPLE3_ORDER idxOrder(2,1,0)
#  define TUPLE4_ORDER idxOrder(3,2,1,0)
#endif

typedef double* Jacobian1D_t @(dim(numElements, NUM_QPTS, 1, 1), TUPLE4_ORDER);
typedef double* Jacobian2D_t @(dim(numElements, NUM_QPTS, 2, 2), TUPLE4_ORDER);
typedef double* Jacobian3D_t @(dim(numElements, NUM_QPTS, 3, 3), TUPLE4_ORDER);

typedef double* Operator1D_t @(dim(numElements, NUM_QPTS, 1), TUPLE3_ORDER);
typedef double* Operator2D_t @(dim(numElements, NUM_QPTS, 3), TUPLE3_ORDER);
typedef double* Operator3D_t @(dim(numElements, NUM_QPTS, 6), TUPLE3_ORDER);

typedef double* Grad1D_t @(dim(numElements, NUM_QPTS, 1), TUPLE3_ORDER);
typedef double* Grad2D_t @(dim(numElements, NUM_QPTS, 2), TUPLE3_ORDER);
typedef double* Grad3D_t @(dim(numElements, NUM_QPTS, 3), TUPLE3_ORDER);

#ifndef CONST_COEFF
typedef double Coeff_t;
#  define COEFF(E, Q) CONST_COEFF
#else
typedef double* Coeff_t @(dim(numElements, NUM_QPTS));
#  define COEFF(E, Q) coeff(E, Q)
#endif

kernel void Assemble1D(const int numElements,
                       const Jacobian1D_t Jt,
                       const Coeff_t coeff,
                       const Operator1D_t oper) {

  for (int eb = 0; eb < numElements; eb += ELEMENT_BATCH; outer) {
    for (int el = eb; el < (eb + ELEMENT_BATCH); ++el; inner) {
      for (int q = 0; q < NUM_QPTS; ++q; inner) {
        oper(el, q, 0) = COEFF(el, q) / Jt(el, q, 0, 0);
      }
    }
  }
}

kernel void Assemble2D(const int numElements,
                       const Jacobian2D_t Jt,
                       const Coeff_t coeff,
                       const Operator2D_t oper) {

  for (int eb = 0; eb < numElements; eb += ELEMENT_BATCH; outer) {
    for (int el = eb; el < (eb + ELEMENT_BATCH); ++el; inner) {
      for (int q = 0; q < NUM_QPTS; ++q; inner) {
        const double J11 = Jt(el, q, 0, 0), J12 = Jt(el, q, 0, 1);
        const double J21 = Jt(el, q, 1, 0), J22 = Jt(el, q, 1, 1);
        const double c_detJ = COEFF(el, q) / ((J11 * J22) - (J21 * J12));

        oper(el, q, 0) =  c_detJ * (J12*J12 + J22*J22); // (1,1)
        oper(el, q, 1) = -c_detJ * (J12*J11 + J22*J21); // (1,2) + (2,1)
        oper(el, q, 2) =  c_detJ * (J11*J11 + J21*J21); // (2,2)
      }
    }
  }
}

kernel void Assemble3D(const int numElements,
                       const Jacobian3D_t Jt,
                       const Coeff_t coeff,
                       const Operator3D_t oper) {

  for (int eb = 0; eb < numElements; eb += ELEMENT_BATCH; outer) {
    for (int el = eb; el < (eb + ELEMENT_BATCH); ++el; inner) {
      for (int q = 0; q < NUM_QPTS; ++q; inner) {
        const int id = el * NUM_QPTS + q;
        const double J11 = Jt(el, q, 0, 0), J12 = Jt(el, q, 0, 1), J13 = Jt(el, q, 0, 2);
        const double J21 = Jt(el, q, 1, 0), J22 = Jt(el, q, 1, 1), J23 = Jt(el, q, 1, 2);
        const double J31 = Jt(el, q, 2, 0), J32 = Jt(el, q, 2, 1), J33 = Jt(el, q, 2, 2);

        const double detJ = ((J11 * J22 * J33) + (J12 * J23 * J31) + (J13 * J21 * J32) -
                             (J13 * J22 * J31) - (J12 * J21 * J33) + (J11 * J23 * J32));
        const double c_detJ = COEFF(el, q) / detJ;

        // adj(J)
        const double A11 = (J22 * J33) - (J23 * J32);
        const double A12 = (J23 * J31) - (J21 * J33);
        const double A13 = (J21 * J32) - (J22 * J31);

        const double A21 = (J13 * J32) - (J12 * J33);
        const double A22 = (J11 * J33) - (J13 * J31);
        const double A23 = (J12 * J31) - (J11 * J32);

        const double A31 = (J12 * J23) - (J13 * J22);
        const double A32 = (J13 * J21) - (J11 * J21);
        const double A33 = (J11 * J22) - (J12 * J23);

        // adj(J)^Tadj(J)
        oper(el, q, 0) = c_detJ * (A11*A11 + A21*A21 + A31*A31); // (1,1)
        oper(el, q, 1) = c_detJ * (A11*A12 + A21*A22 + A31*A32); // (1,2) + (2,1)
        oper(el, q, 2) = c_detJ * (A11*A13 + A21*A23 + A31*A33); // (1,3) + (3,1)
        oper(el, q, 3) = c_detJ * (A12*A12 + A22*A22 + A32*A32); // (2,2)
        oper(el, q, 4) = c_detJ * (A12*A13 + A22*A23 + A32*A33); // (2,3) + (3,2)
        oper(el, q, 5) = c_detJ * (A13*A13 + A23*A23 + A33*A33); // (3,3)
      }
    }
  }
}

kernel void Mult1D(const int numElements,
                   const Operator1D_t oper,
                   Grad1D_t restrict sol) {
  // Iterate over elements
  for (int eb = 0; eb < numElements; eb += ELEMENT_BATCH; outer) {
    for (int el = eb; el < (eb + ELEMENT_BATCH); ++el; inner) {
      // Element computation
      // [MISSING] B*sol
      for (int q = 0; q < NUM_QPTS; ++q; inner) {
        sol(el, q, 0) *= oper(el, q, 0);
      }
      // [MISSING] B^T*sol
    }
  }
}

kernel void Mult2D(const int numElements,
                   const Operator2D_t oper,
                   Grad2D_t restrict sol) {
  // Iterate over elements
  for (int eb = 0; eb < numElements; eb += ELEMENT_BATCH; outer) {
    for (int el = eb; el < (eb + ELEMENT_BATCH); ++el; inner) {
      // Element computation
      // [MISSING] B*sol
      for (int q = 0; q < NUM_QPTS; ++q; inner) {
        const double O11 = oper(el, q, 0);
        const double O12 = oper(el, q, 1);
        const double O22 = oper(el, q, 2);

        const double x = sol(el, q, 0);
        const double y = sol(el, q, 1);

        sol(el, q, 0) = (O11 * x) + (O12 * y);
        sol(el, q, 1) = (O12 * x) + (O12 * y);
      }
      // [MISSING] B^T*sol
    }
  }
}

kernel void Mult3D(const int numElements,
                   const Operator3D_t oper,
                   Grad3D_t restrict sol) {
  // Iterate over elements
  for (int eb = 0; eb < numElements; eb += ELEMENT_BATCH; outer) {
    for (int el = eb; el < (eb + ELEMENT_BATCH); ++el; inner) {
      // Element computation
      // [MISSING] B*sol
      for (int q = 0; q < NUM_QPTS; ++q; inner) {
        const double O11 = oper(el, q, 0);
        const double O12 = oper(el, q, 1);
        const double O13 = oper(el, q, 2);
        const double O22 = oper(el, q, 3);
        const double O23 = oper(el, q, 4);
        const double O33 = oper(el, q, 5);

        const double x = sol(el, q, 0);
        const double y = sol(el, q, 1);
        const double z = sol(el, q, 2);

        sol(el, q, 0) = (O11 * x) + (O12 * y) + (O13 * z);
        sol(el, q, 1) = (O12 * x) + (O22 * y) + (O23 * z);
        sol(el, q, 2) = (O13 * x) + (O23 * y) + (O33 * z);
      }
      // [MISSING] B^T*sol
    }
  }
}