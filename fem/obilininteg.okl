/*
  ---[ Defines Known At Compile-Time ]------------
  ELEMENT_BATCH : How many elements are in each
  .               computation batch
  NUM_DOFS      : Dofs per element
  NUM_QPTS      : Quadrature points per element
  NUM_VDIM      : Solution vector dimensions (number of fields)
  COEFF_EVAL    : Coefficient evaluator for each
  .               quadrature point
  ================================================
*/

#if OCCA_USING_GPU
#  define JT_IDX_ORDER   idxOrder(2,0,1)
#  define GRAD_IDX_ORDER idxOrder(3,2,0,1)
#else
#  define JT_IDX_ORDER   idxOrder(2,1,0)
#  define GRAD_IDX_ORDER idxOrder(3,2,1,0)
#endif

typedef double* Jt_1D_t @(dim(numElements, NUM_QPTS, 1), JT_IDX_ORDER);
typedef double* Jt_2D_t @(dim(numElements, NUM_QPTS, 4), JT_IDX_ORDER);
typedef double* Jt_3D_t @(dim(numElements, NUM_QPTS, 9), JT_IDX_ORDER);

typedef double* grad_1D_t @(dim(numElements, NUM_QPTS, NUM_VDIM, 1), GRAD_IDX_ORDER);
typedef double* grad_2D_t @(dim(numElements, NUM_QPTS, NUM_VDIM, 2), GRAD_IDX_ORDER);
typedef double* grad_3D_t @(dim(numElements, NUM_QPTS, NUM_VDIM, 3), GRAD_IDX_ORDER);

// Make the integrators methods
// 1 kernel iterates over elements

/*
  Integ mainly depends on
    - Jacobian
    - Jacobian determinant
    - Jacobian adjugate
    - Physical coordinates

  void DomainIntegrator(const double w_detJ
                        const double J[4],
                        const int el,
                        const int q)
*/
/*
kernel () {
  for (element) {
    // Compute Jacobian, deter ... (only what is needed)
    for (quad) {
    }
  }
}
*/

kernel void DiffusionIntegrator1D(const int numElements,
                                  const Jt_1D_t restrict Jt,
                                  grad_1D_t restrict grad) {

  for (int eb = 0; eb < numElements; eb += ELEMENT_BATCH; outer0) {
    for (int el = eb; el < (eb + ELEMENT_BATCH); ++el; inner1) {
      // Apply B (solFEval)

      // Over QPTS (all domain integrators)
      for (int q = 0; q < NUM_QPTS; ++q; inner0) {
        const double w = COEFF_EVAL(el, q) / Jt(el, q, 0);
        for (int f = 0; f < NUM_VDIM; ++f) {
          // grad_qpts = (w/det(J)) (adj(J) adj(J)^T grad_qpts)
          // For the 1x1 case: adj(J) = 1
          grad(el, q, f, 0) *= w;
        }
      }

      // Apply B^T (solFEval)
    }
  }
}

kernel void DiffusionIntegrator2D(const int numElements,
                                  const Jt_2D_t restrict Jt,
                                  grad_2D_t restrict grad) {

  for (int eb = 0; eb < numElements; eb += ELEMENT_BATCH; outer0) {
    for (int el = eb; el < (eb + ELEMENT_BATCH); ++el; inner1) {
      for (int q = 0; q < NUM_QPTS; ++q; inner0) {
        const int id = el * NUM_QPTS + q;
        const double J11 = Jt(el, q, 0), J12 = Jt(el, q, 1);
        const double J21 = Jt(el, q, 2), J22 = Jt(el, q, 3);
        const double w_detJ = COEFF_EVAL(el, q) / ((J11 * J22) - (J21 * J12));

        for (int f = 0; f < NUM_VDIM; ++f) {
          const double x1 = grad(el, q, f, 0);
          const double x2 = grad(el, q, f, 1);
          // z = adj(J)^T x
          const double z1 = (J22 * x1) - (J21 * x2);
          const double z2 = (J11 * x2) - (J12 * x1);
          // grad_qpts = (w/det(J)) (adj(J) adj(J)^T grad_qpts)
          grad(el, q, f, 0) = w_detJ * ((J22 * z1) - (J12 * z2));
          grad(el, q, f, 1) = w_detJ * ((J11 * z2) - (J21 * z1));
        }
      }
    }
  }
}

kernel void DiffusionIntegrator3D(const int numElements,
                                  const Jt_3D_t restrict Jt,
                                  grad_3D_t restrict grad) {

  for (int eb = 0; eb < numElements; eb += ELEMENT_BATCH; outer0) {
    for (int el = eb; el < (eb + ELEMENT_BATCH); ++el; inner1) {
      for (int q = 0; q < NUM_QPTS; ++q; inner0) {
        const int id = el * NUM_QPTS + q;
        const double J11 = Jt(el, q, 0), J12 = Jt(el, q, 1), J13 = Jt(el, q, 2);
        const double J21 = Jt(el, q, 3), J22 = Jt(el, q, 4), J23 = Jt(el, q, 5);
        const double J31 = Jt(el, q, 6), J32 = Jt(el, q, 7), J33 = Jt(el, q, 8);

        const double detJ = ((J11 * J22 * J33) + (J12 * J23 * J31) + (J13 * J21 * J32) -
                             (J13 * J22 * J31) - (J12 * J21 * J33) + (J11 * J23 * J32));
        const double w_detJ = COEFF_EVAL(el, q) / detJ;

        // adj(J)
        const double AJ11 = (J22 * J33) - (J23 * J32);
        const double AJ12 = (J23 * J31) - (J21 * J33);
        const double AJ13 = (J21 * J32) - (J22 * J31);

        const double AJ21 = (J13 * J32) - (J12 * J33);
        const double AJ22 = (J11 * J33) - (J13 * J31);
        const double AJ23 = (J12 * J31) - (J11 * J32);

        const double AJ31 = (J12 * J23) - (J13 * J22);
        const double AJ32 = (J13 * J21) - (J11 * J21);
        const double AJ33 = (J11 * J22) - (J12 * J23);

        for (int f = 0; f < NUM_VDIM; ++f) {
          const double x1 = grad(el, q, f, 0);
          const double x2 = grad(el, q, f, 1);
          const double x3 = grad(el, q, f, 2);
          // z = adj(J)^T x
          const double z1 = (AJ11 * x1) + (AJ21 * x2) + (AJ31 * x3);
          const double z2 = (AJ12 * x1) + (AJ22 * x2) + (AJ32 * x3);
          const double z3 = (AJ13 * x1) + (AJ23 * x2) + (AJ33 * x3);
          // grad_qpts = (w/det(J)) (adj(J) adj(J)^T grad_qpts)
          grad(el, q, f, 0) = w_detJ * ((AJ11 * z1) + (AJ12 * z2) + (AJ13 * z3));
          grad(el, q, f, 1) = w_detJ * ((AJ21 * z1) + (AJ22 * z2) + (AJ23 * z3));
          grad(el, q, f, 2) = w_detJ * ((AJ31 * z1) + (AJ32 * z2) + (AJ33 * z3));
        }
      }
    }
  }
}
